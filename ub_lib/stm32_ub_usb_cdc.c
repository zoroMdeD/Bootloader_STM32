//--------------------------------------------------------------
// File     : stm32_ub_usb_cdc.c
// Datum    : 23.06.2013
// Version  : 1.4
// Autor    : UB
// EMail    : mc-4u(@)t-online.de
// Web      : www.mikrocontroller-4u.de
// CPU      : STM32F4
// IDE      : CooCox CoIDE 1.7.0
// Module   : GPIO, MISC
// Funktion : USB-COM-Verbindung per USB-OTG-Port am Discovery
//
// Примечание:  На компьютер необходимо установить 
// 		"VirtualComportDriver" версии (V 1.3.1) только в 
// 		том случае виртуальный COM-порт будет 
// 		отображается в диспетчере устройств
//
//		Модуль Discovery работает только USB Full режиме 
//		(USB-High-Speed не работает)
//
//--------------------------------------------------------------
//              PA8   -> USB_OTG_SOF (не используется)
//              PA9   -> USB_OTG_VBUS
//              PA10  -> USB_OTG_ID
//              PA11  -> USB_OTG_DM
//              PA12  -> USB_OTG_DP
//--------------------------------------------------------------

//--------------------------------------------------------------
// Includes
//--------------------------------------------------------------
#include "stm32_ub_usb_cdc.h"

//--------------------------------------------------------------
// Глобальная переменная
//--------------------------------------------------------------
USB_OTG_CORE_HANDLE  USB_OTG_dev;





//--------------------------------------------------------------
// Инициализация USB-OTG-порта как CDC-устройство
// (Виртуальный COM порт)
//--------------------------------------------------------------
void UB_USB_CDC_Init(void)
{
  USB_CDC_STATUS=USB_CDC_DETACHED;
  USBD_Init(&USB_OTG_dev, USB_OTG_FS_CORE_ID, &USR_desc, &USBD_CDC_cb, &USR_cb);
}

//--------------------------------------------------------------
// читать состояние интерфейса USB
// Возвращаемое значение :
// ->  USB_CDC_NO_INIT =0, // интерфейс USB не инициализирован 
// ->  USB_CDC_DETACHED,   // USB-соединение инициализировано
// ->  USB_CDC_CONNECTED   // USB-Соединение установлено
//--------------------------------------------------------------
USB_CDC_STATUS_t UB_USB_CDC_GetStatus(void)
{
  return(USB_CDC_STATUS);
}


//--------------------------------------------------------------
// Посылка строки через интерфейс OTG USB
// команда в конце : [NONE, LFCR, CRLF, LF, CR]
// Возвращаемое значение :
//  -> ERROR   , строка не отправлена
//  -> SUCCESS , строка отправлена
//--------------------------------------------------------------
ErrorStatus UB_USB_CDC_SendString(char *ptr, USB_CDC_LASTBYTE_t end_cmd)
{

  if(USB_CDC_STATUS!=USB_CDC_CONNECTED) {
  // передавать только, когда соединение установлено
    return(ERROR);
  }

  // Отправить строку целиком
  while (*ptr != 0) {
    UB_VCP_DataTx(*ptr);
    ptr++;
  }
  // отправка конечного идентификатора
  if(end_cmd==LFCR) {
    UB_VCP_DataTx(0x0A); // Возврат строки
    UB_VCP_DataTx(0x0D); // Перевод каретки
  }
  else if(end_cmd==CRLF) {
    UB_VCP_DataTx(0x0D); // Перевод каретки
    UB_VCP_DataTx(0x0A); // Возврат строки
  }
  else if(end_cmd==LF) {
    UB_VCP_DataTx(0x0A); // Возврат строки
  }
  else if(end_cmd==CR) {
    UB_VCP_DataTx(0x0D); // Перевод каретки
  }

  return(SUCCESS);
}



//--------------------------------------------------------------
// получение строки через интерфейс OTG USB
// (прием реализуется с помощью прерывания)
// Эта функция должна опрашиваться циклически
// Возвращаемое значение :
//  -> если USB не готов = RX_USB_ERR
//  -> если ничего не получено = RX_EMPTY
//  -> если строка получена = RX_READY -> Строка в *ptr
//--------------------------------------------------------------
USB_CDC_RXSTATUS_t UB_USB_CDC_ReceiveString(char *ptr)
{
  uint16_t check;

  if(USB_CDC_STATUS!=USB_CDC_CONNECTED) {
    // прием только тогда, когда соединение установлено
    return(RX_USB_ERR);
  }

  check=UB_VCP_StringRx(ptr);
  if(check==0) {
    ptr[0]=0x00;
    return(RX_EMPTY);
  }

  return(RX_READY);
}

//------------------------------------Измененная функция для приема всех симфолов ASCII------------------------------------
//--------------------------------------------------------------
// получение строки через интерфейс OTG USB
// (прием реализуется с помощью прерывания)
// Эта функция должна опрашиваться циклически
// Возвращаемое значение :
//  -> если USB не готов = RX_USB_ERR
//  -> если ничего не получено = RX_EMPTY
//  -> если строка получена = RX_READY -> Строка в *ptr
//--------------------------------------------------------------
USB_CDC_RXSTATUS_t UB_USB_CDC_ReceiveString_NEW(char *ptr)
{
  uint16_t check;

  if(USB_CDC_STATUS!=USB_CDC_CONNECTED) {
    // прием только тогда, когда соединение установлено
    return(RX_USB_ERR);
  }

  check=UB_VCP_StringRx_NEW(ptr);
  if(check==0) {
    ptr[0]=0x00;
    return(RX_EMPTY);
  }

  return(RX_READY);
}
//-------------------------------------------------------------------------------------------------------------------------
